

'''

метафреймворк на основе синатrы

скорее даже сайт-конструктор

может всётаки сразу на лиспе, а не на ruby?



структура модели

куски данных (в том числе css,js и статический html) - текст, числа, даты, файлы, сцылки,
составные объекты - дерево ключ-значение

шаблоны - объекты с пустыми значениями ключей,
эти ключи - интерфейс

можно реализовывать функции для выполнения подстановки

далее - страницы
есть дерево страниц по путям (ссылки и структура сайта не при чём, меня там всякие...)

финальный кусок данных первращается в страницу только если он page-model

у него есть layout и content
layout фактически это голый шаблон с минимум данных
в него засовывается content так-же как и в любой другой шаблон
а потом на него навешивается оформление на css, js и т.д.
и на выходе получается уже не дерево данных, а дерево html

т.е. layout, например может содержать поля: header, footer, center, left bar, right bar, css list, js list


таак, а как преобразовать деревья забинденые например в header из дерева ключ-значение в html ?

видимо после процедуры сборки из кусков данных целого дерева content
надо произвести обратную процедуру разбора, с использованием каких-то преобразований, принадлежащих целиком page-model
т.е. если layout - это корневой template, то должны быть ещё и вложенные

такми образом получается ещё и дерево template-ов

только есть template-ы которорые формируют данные, а есть которые формируют html

а собственно из чего получаются данные которые формируют content?

приходит запрос, он преобразуется в дерево, которое request (в него входит всё что пришло по http включая куки)
далее различные его части могут использоваться для выполнения например запросов к бд, данным сессии, и т.д.

т.е. есть обработчик статического пути (который страница в предшевствующей нотации)
он это всё и делает - в нём определены преобразования из входящих данных
(т.е. шаблон параметров - и куда они подставляются например в запросе к бд)
и последующее преобразование ответа бд в структуру данных - дерево ключ-значение

причем обработка запроса сразу разделена на два этапа - изменение, и получение данных для отображения
один из этапов, в принципе, может быть пустым


для разворачивания вместе с этим движком должен поставляться минимальный набор layout-ов, шаблонов, запросов, типов данных и прочего



!!!!!!!!!!!!!!!


эту хрень наверное можно отвязать от веба вообще - для разработки и тестирования как минимум

основные составляющие части:

	1) дерево страниц - путей
	2) вложенные списки пар ключ-значение, и ключ-много-значений - как основные структуры данных
	3) обработчик страницы из n последовательных частей
	3) шаблоны для разбора запроса
	3) объект данных передается из одной части в другую последовательно
	4) преобразование элементов запроса в запросы к другим сервисам (бд, сессия, ...)
	5) преобразование ответов от них к внутреннему представлению данных
	6) формирование объекта content с помощью механизма шаблонов
	7) параллельно формирование объекта layout с помощью того-же механизма
	8) раскладываение данных content-a в layout



можно попробовать запрототипировать на метапитончике

'''

_placeholder_ = None

_ = _placeholder_



pages = { "users":_, "projects":_,
	"meta" : {"contacts":_, "about":_, "map":_},
	"main":_ }

request_templates = { "users" : {"order":_,
		"filter" : {"age":_, "active":_, "village":_} } }


'''
data - нет плейсхолдеров
template - могут быть
interface - только плейсхолдеры

операции:

	TODO: раздедить на общие операции с деревьями и операции с деревьями значения ключей которых могут быть плейсхолдеры


	filter, split - самая общая операция, разделяющая дерево на несколько по какому-то признаку, фильтр выдает одно поддерево а сплит сразу все

	iface(template) -> interface
		достать голый интерфейс из шаблона
		в общем виде - разделить дерево на два на основании того значение ключа плейсхолдер или данные


	extract(interface, template) -> data, template, interface
		экстрагирование того что надо интерфейсу из объекта
		фильтр, применение интерйеса
		в общем виде - получаем две части - дерево с данными, незаполненный интерфейс, и всё вместе

	merge(template, template)
		слияние двух деревьев рекурсивно
		сумма
		если ключ уже есть - к его значениям добавляются ещё
		варианты с заменой атомарных значений (приоритет у первого или второго)
		и с преобразованием атомарного значения в список
		плейсхолдеры само собой заменяются на значения

	если что вдруг - наследование - это последовательное слияние с заменой


	diff(template, template)
		разница между двумя деревьями
		разность
		результат - общие ключи, и остатки первого и второго


ещё нужна операция которая из значений делает ключи и наоборот, инвертирующая ключи и значения

дополнительный инструмент для работы с интерфейсами - условия:
	??? - обязательный/необязательный, список 1 и более (необязательный 0 и более), вариант один на выбор
	;) - последовательность - неактуально, но применимо например для последовательности преобразований
	группировка присутствует по-умолчанию - дерево-же

'''



page_handlers = { "users" :
	[
	(),
	lambda (request) :
		r = extract(request_templates["users"], request)
		return merge(
			{"user_list" : sql_orm_select(from:"users", where:r["filter"], sort:r["order"])},
			{"username" : session_get("sid":extract({"sid":_}, request))}
		)
	]
}


menu_content = { slice_level(pages, 1) }

pages_content_templates = { "users" :
	{ "username" : _ ,  "user_list" : _ }

}

# фактичски layout - это правила куда подсовывать данные из контента в какой html шаблон
pages_layouts = { "users" :

	# TODO: тут надо как-то указать что каждый элемент из "user_list" надо заворачивать в html_templates["user"]
	# а в то же время весь "user_list" в  html_templates["list_of_smth"]
	# короче надо разобраться как указать  весь список или каждый элемент

	{"header" : { "hello" : "username", "menu" : menu_content } ,
	"center" : { "list_of_smth" : "user_list"}}

}

html_templates = {
	"list_of_smth" :
	# тут оформление списка в виде например таблицы
	,
	"user" :
	# тут оформление отображения данных юзера в html
	,
	"menu" : ...
	"hello" : ...
	"page" : ...
	"header" : ...
}


presenter (path, request) :
	# запускаем запрос в page_handlers[path]
	# результат фильтруем через pages_content_templates[path]
	# полученное подсовываем в pages_layouts[path]
	# полученный layout с данными заворачивается в соответсвующий html из html_templates

	return html_templates["page"] .....






































