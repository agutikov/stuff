







'''

Изначально идея была в том чтобы использовать те-же конструкции для формирования атомов, что и для формирования выражений.
Но со строками гораздо удобнее работать с помощью уже существующих регекспов, чем выдумывать свои правила и инструменты.

Списки строк: фиксированные, нефиксированные - проверяемые регулярными выражениями
Атомы, лексемы, слова, и т.д.

Описание грамматики - дерево с узлами.
Узлы могут быть терминалами, которым в дереве синтаксического разбора будут соотвествовать атомарные лексемы.
Узлы могут быть нетерминалами, которым в дереве синтаксического разбора будут соотвествовать составные элементы.

В описании грамматики каждому неделимому элементу (терминалу) соответствует следующее описание:
- уникальное имя, по которому к нему можно обращаться
- флаг - фиксированный набор строк или нефиксированный
- что-то для проверки является ли строка таким терминалом (список возможных строк, регулярное выражение)
Фактически, т.к. обычно у каждого зарезервированного слова или знака своё значение то будет не список возможных строк, а одна возможная строка.
Но это уже зависит от детализированности - например можно считать знаки [+ - * /] разными, а можно одним списком.
По идее для того чтобы иметь возможность проверять конкретно какой знак использовался удобнее будет рассматривать их как отдельные терминалы.

В описании грамматики каждому нетерминалу соответствует следующее описание:
- уникальное имя
- дерево из терминалов и нетерминалов объединённых следующими операциями:
	- set (выбор, или) с возможностью использовать пустой элемент
	- sequence из определённого количества различных элементов
	- loop - последовательность одинаковых элементов заданного количества
		количество задаётся одним числом или диапазоном,
		прикольно было бы иметь возможность использовать диапазоны с разрывами или, например, периодические диапазоны, или вообще функционально-определённые
	!!! Важный момент - в результате в каждом конкретном узле должна получиться обычная последовательность, 
	поэтому в дереве разбора цикл будет разворачиваться в последовательность и объединяться с родительской последовательностью.

Разбираемый текст - обычный массив символов, где каждый символ пронумерован и на него можно ссылаться откуда угодно.

Результат рабора - дерево разбора вместе со вспомогательными элементами:
- Дерево из синаксических единиц, только последовательности и parent-child (как в xml)
	Каждый элемент имеет:
	- ссылку на описание типа в этом конкретном разборе 
	  не на сам узел в описании граматики, а на ещё один промежуточный объект, который представляет свзязь между грамматикой как таковой и этим конкретным результатом разбора
	Каждый терминальный элемент - атом:
	- значение - указание на место в тексте и сама строка
	Каждый нетерминальный элемент - выражение:
	- список элементов из которых он состоит (по порядку следования в тексте)

Вспомогательные объекты на которые ссылаются как на тип элементы дерева разбора,
и на которые ссылаются как на использование типа элементы описания грамматики.
Назовём их описание использования.
- ссылка на тип - элемент описания грамматики
- для всех типов - список вхождений, список ссылок на элементы дерева разбора
- для терминальных типов - список всех строк (для фиксированного набора - всех вообще возможных, для нефиксированного - использованных в данном тексте)
	- для каждой такой строки список использований в тесте - список ссылок на элементы дерева разбора

--------

Процесс разбора:

1) Есть грамматика (дерево) и текст
2) Для каждого узла дерева грамматики создаём по объекту описания использования.
3) Создаём корневой узел дерева разбора.

Основной курсор стоит в конце уже разобранного участка текста, в начале участка, значение которого ещё не определено.
Дополнительный курсор движется вперёд от основного добаляя символы во временный буфер.
При разборе символы из этого буфера сравниваются с шаблонами терминалов.
При этом терминалы с которыми сравнивается буфер выбираются в соотвествии с контекстом.
Есть в текущем дереве разбора уже зафиксированные узлы - те которые уже точно есть.
В процессе создаются временные узлы, из тех которыми может оказаться текущий буфер.
У текущей неопознанной ещё конструкции точно есть parent - родительский элемент и возможно уже есть предыдущий сосед.
Идём по поддереву описания грамматики соответствующему типу родительского элемента дерева разбора.
Идём вниз и создаём временные объекты дерева разбора - если у нас set (выбор из нескольких) - создаём все, 
если последовательность - учитываем предыдущие элементы, если цикл - учитываем количество.
Для хранения информации о временных объектах нужны вспомогательные объекты которые будут проводить выбор, вести учёт количества или проверять последовательность.
Если какие-то возможные объекты структуры не проходят проверку - удаляем их.
Так доходим вниз до временных терминальных объектов.
Проверяем каждый возможный терминальный объект, отбрасываем (удаляем) те которые не прошли проверку.
Обновляем дерево временных объектов - идём по дереву вверх и удаляем те у которых не осталось возможных chuild-ов.
Когда остаётся только один временный объект - можно переносить его в постоянные и двигаться дальше в зависимости от типа текущего родительского узла.
Если, например, выбор и один элемент уже выбрали или цикл и все возможные элементы закончились - можно фиксировать текущие элементы, 
их parents-ов и создавать новый временный объект там где это возможно по правилам грамматики.



Например мы разбираем арифметическое выражение с вещественными числами в десятичном представлении у которого есть терминалы:
open_bracket = '('
close_bracket = ')'
plus = '+'
minus = '-'
multiply = '*'
divide = '/'
number = "[+-]?(([1-9][0-9]*)|(0))([.,][0-9]+)?"

Нетерминалы:
root = minor_operand
minor_operand = statement_in_brackets or number or major_operation or minor_operation
major_operand = statement_in_brackets or number or major_operation
minor_operation = minor_operand then minor_operator then minor_operand
major_operation = major_operand then major_operator then major_operand
major_operator = multipy or divide
major_operator = multipy or divide
statement_in_brackets = open_bracket then minor_operand then close_bracket



WTF?! рекурсия или циклы ?



==============================

Дополнительно.
0) Множество файлов. Инклюды.
1) Строки в файле. В какой строке находится лексемма, сколько строк занимает выражение и т.д.
2) Препроцессор. Найти использования макроса и найти использование переменной после раскрытия макросов.
3) Строковые литералы в С переносимые через конец строки и объединяемые при компиляции.
4) Оформление комментариев.
5) Области видимости.


'''





